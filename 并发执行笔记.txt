多事务执行方式：
    事务串行执行
    交叉并发执行
    同时并发执行
并发的问题：可能会破坏事务的隔离性和数据库的一致性
并发操作的潜在不一致性：
    丢失修改
    不可重复读
	三种不可重复读：
	事务1读取某一数据后：
	    事务2对其做了修改
	    事务2删除了其中部分记录
	    事务2插入了一些记录
    读脏数据

封锁：
排他锁（X锁，写锁）
    若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放对A的锁
共享锁（S锁）
    若事务T对数据对象A加上S锁，则其他事务智能再对A加S锁，而不能加X锁，直到T释放A上的S锁

封锁协议：何时申请锁、持续时间、何时释放

1级封锁协议：
事务T再修改数据R之前必须先对其加X锁，直到事务结束才释放
    1级封锁协议可防止丢失修改，如果是读书，不需要加锁，不能保障可重复读和不读脏数据

2级封锁协议：
1级封锁协议+事务T子啊读取数据R前必须先加S锁，读完后即可释放S锁
    可以防止丢失修改和读脏数据，但是不能保证可重复读

3级封锁协议：
1级封锁协议+事务T子啊读取数据R前必须先加S锁，直到事务结束后即可释放S锁
    可以防止丢失修改和读脏数据，可以保证可重复读
活锁：一个事务总是不能再某数据项上加上锁，因此该事务也就永远不能取得进展
活锁的避免：先来先服务
死锁：由于事务占有锁且申请其他的锁，使得这些事务不能继续推进的这种情况
解决死锁：
    预防死锁：
	一次封锁法：所有事务一次性将所用的数据全部加锁（降低并发度）
	顺序封锁：对数据对象按事先规定的顺序进行顺序封锁
解除死锁：选择一个处理死锁代价最小的事物，将其撤销，释放该事物持有的所以的锁。

正确的调度策略：将所有的事物串行起来的调度策略一定是正确的调度策略
当且仅当其结果与按某一次序串行的执行他们的结果相同（可串行化的调度）
可串行性是并行事务正确性的唯一准则
保证并发操作调度正确性的方法：
    封锁协议（两段锁协议）：
	1、在对任何数据进行读写操作之前，事务首先要活的对该数据的封锁
	2、在释放一个封锁之后、事务不再活的任何其他封锁
	例如：
	T:遵守两段锁协议
	Slock A
	Slock B
	Xlock C
	Unlock B
	Unlock A
	Unlock C
    所有遵守两段锁协议的事务，其并行执行的结果一定是正确的，但是可串行化的调度中，不一定所有事务都必须符合两段锁协议
    （一次封锁法一定遵守两段锁协议，但是遵守两段锁协议的事务可能发生死锁（因为两段锁协议不要求一次性获得所有封锁））

两段锁协议：保证并发调度的正确性
三级封锁协议：在不同程度上保证数据的一致性

遵守第三极封锁协议的事务必然遵守两段锁协议

封锁对象的大小成为封锁粒度
显式封锁：直接加到数据对象上的封锁
隐式封锁：由于其上级节点加锁而使该数据对象加锁

对某个数据对象进行加锁的时候系统检查的内容：
    该数据对象：有无显式封锁与其冲突
    所有间接或直接上级结点
    所有下级结点
意向锁：对任一结点加基本锁，必须先对它的上层结点加意向锁，如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁

意向共享锁：IS
意向排他锁：IX
共享意向排他锁：SIX = S +IX，如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁（对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要加IX锁））

具有意向锁的多粒度封锁方法：
    申请封锁：自上而下
    释放封锁：自下而上

小结：
数据共享与数据一致性是一对矛盾
    数据库的价值在很大程度上取决于它所能提供的数据共享度
    数据共享在很大程度上取决于系统允许对数据并发操作的程度
    数据并发程度又取决于数据库中的并发控制机制
    另一方面，数据的一致性也取决于并发控制的程度，施加的并发控制越多，数据的一致性往往越好
数据库的并发控制以事务为单位
数据库的并发控制通常使用封锁机制
不同级别的封锁协议提供不同的数据一致性保证，提供不同的数据共享度
并发控制机制调度并发事务操作是否正确的判别标准是可串行化
